<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>QtDragon Documentation</title>
  <link href="help.css" rel="stylesheet">
</head>
<body>

<h1>USING A VFD</h1>
<p>QtDragon was designed to communicate with a VFD via modbus. A custom HAL component provides the modbus interface between
QtDragon and a Huanyang GT Series VFD. <p>The following HAL connections must be added to the qtdragon_postgui.hal file:</p>

<div class="code-block">
    <pre class="hal">loadusr -Wn gt_vfd ./hy_gt_vfd.py -d /dev/ttyUSB0 [other args]</pre>
    <pre class="hal">net spindle-on       gt_vfd.spindle-on <= spindle.0.on</pre>
    <pre class="hal">net spindle-fb       gt_vfd.speed-fb => spindle.0.speed-in</pre>
    <pre class="hal">net spindle-cmd      gt_vfd.speed-cmd <= spindle.0.speed-out-abs</pre>
    <pre class="hal">net spindle-amps     gt_vfd.output-amps => qtdragon.spindle_amps</pre>
    <pre class="hal">net spindle-volts    gt_vfd.output-volts => qtdragon.spindle_volts</pre>
    <pre class="hal">net spindle-fault    gt_vfd.fault-info => qtdragon.spindle_fault</pre>
    <pre class="hal">net modbus-errors    gt_vfd.modbus-errors => qtdragon.modbus-errors</pre>
    <pre class="hal">net vfd-ok           gt_vfd.vfd-ok => qtdragon.vfd-ok</pre>
    <pre class="hal">net spindle-fwd      spindle.0.forward => and2.0.in1</pre>
    <pre class="hal">net at-speed-fwd     spindle.0.at-speed <= and2.0.out</pre>
    <pre class="hal">net at-speed-fwd     qtdragon.hal_led_atspeed</pre>
</div>

<p>Optional arguments for hy_gt_vfd.py are:</p>
<table>
<tr>
    <td>-d</td><td>--device</td><td>serial device to connect to</td>
</tr>
<tr>
    <td>-b</td><td>--bits</td><td>number of bits in a byte</td>
</tr>
<tr>
    <td>-r</td><td>--rate</td><td>baud rate</td>
</tr>
<tr>
    <td>-p</td><td>--parity</td><td>odd, even or none</td>
</tr>
<tr>
    <td>-p</td><td>--parity</td><td>odd, even or none</td>
</tr>
<tr>
    <td>-s</td><td>--stopbits</td><td>1 or 2</td>
</tr>
<tr>
    <td>-t</td><td>--slave</td><td>modbus slave address (address of VFD)</td>
</tr>
<tr>
    <td>-M</td><td>--maxrpm</td><td>maximum spindle RPM</td>
</tr>
<tr>
    <td>-m</td><td>--minrpm</td><td>minimum spindle RPM</td>
</tr>

</table>
<p>The spindle gauge widget is connected with:</p>

<div class="code-block">
    <pre class="hal">net spindle-cmd      qtdragon.gauge_spindle_setpoint</pre>
    <pre class="hal">net gauge_value      qtdragon.gauge_spindle_value <= gt_vfd.speed-rpm</pre>
</div>

<h2>Default Parameters</h2>
If no arguments are included when loading the hy_gt_vfd HAL module, the following defaults will be used:
<ul>
    <li>device  - /dev/ttyUSB0</li>
    <li>parity  - N - none</li>
    <li>bytes   - 8 bits per byte</li>
    <li>stop    - 1 bit</li>
    <li>baud    - 38400 bits/sec</li>
    <li>slave   - 1</li>
    <li>min rpm - 7200</li>
    <li>max rpm - 24000</li>
</ul>
<h2>Link Disruptions</h2>
<p>In the case of temporary errors in communicating with the VFD, such as line noise or a loose connection in the RS-485 interface, the
modbus errors field in the SETTINGS page is incremented for each error occurance. The errors are also indicated on the message statusbar.</p>
<p>In the case of a loss of communication with the VFD, such as the USB cable being disconnected, any running program will be stopped and a
critical message is displayed on the statusbar. When the USB connection is re-established, a new modbus connection is created and the modbus error
register count is reset to 0.</p>
<p>NOTE that if VFD communication is lost while the spindle is running, there is no way to turn it off until communication is restored or it is
turned off by some other means outside the scope of the UI. (ie. power cycle)</p>

<div class="admonition">
    <p>NOTE: The hy_gt_vfd.py module requires the python pymodbus library.</p>
    <p>sudo apt install python3-pymodbus</p>
</div>
</body>
</html>
